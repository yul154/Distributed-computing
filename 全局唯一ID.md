# Why unique ID

在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性


# UUID
> Universally Unique Identifier


UUID是由一组32位数的16进制数字所构成
* 所以UUID理论上的总数为 16^32=2^128，约等于 3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完
* 生成的UUID是由 8-4-4-4-12格式的数据组成，其中32个字符和4个连字符' - '
* `123e4567-e89b-12d3-a456-426614174000`


UUID的产生方式有5种版本
* 基于时间的UUID : 当前时间，随机数，和本地Mac地址来计算出来，`UuidUtil.getTimeBasedUuid()`来使用。由于使用了MAC地址，因此能够确保唯一性，但是同时也暴露了MAC地址，私密性不够好
* DCE安全的UUID: 安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到
* 基于名字的UUID(MD5): 通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的
* 基于名字的UUID(SHA1) : 和基于名字的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法
* 随机UUID : 根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但是重复的可能性可以忽略不计，因此该版本也是被经常使用的版本。JDK中使用的就是这个版本

```
UUID uuid = UUID.randomUUID();
```

**缺点**
* 不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用
* 信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，暴露使用者的位置
* 对MySQL索引不利：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能，可以查阅 Mysql 索引原理 B+树的知识

----

# 数据库生成

我们将分布式系统中数据库的同一个业务表的自增ID设计成不一样的起始值，然后设置固定的步长，步长的值即为分库的数量或分表的数量
* `auto_increment_offset`：表示自增长字段从那个数开始，他的取值范围是1 .. 65535。 
* `auto_increment_increment`：表示自增长字段每次递增的量，其默认值是1，取值范围是1 .. 65535。


* 依赖于数据库自身不需要其他资源，并且ID号单调自增，可以实现一些对ID有特殊要求的业务。
* 它强依赖DB，当DB异常时整个系统不可用。虽然配置主从复制可以尽可能的增加可用性
* 数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。还有就是ID发号性能瓶颈限制在单台MySQL的读写性能

----
# 使用redis实现

Redis实现分布式唯一ID主要是通过提供像`INCR`和`INCRBY`这样的自增原子命令
* 由于Redis自身的单线程的特点所以能保证生成的 ID 肯定是唯一有序的。
* 集群的方式又会涉及到和数据库集群同样的问题，所以也需要设置分段和步长来实现。
* 为了避免长期自增后数字过大可以通过与当前时间戳组合起来使用，另外为了保证并发和业务多线程的问题可以采用 Redis + Lua的方式进行编码，保证安全。
* Redis实现分布式全局唯一ID，它的性能比较高，生成的数据是有序的，对排序业务有利，但是同样它依赖于redis，需要系统引进redis组件，增加了系统的配置复杂性。
----
# 雪花算法-Snowflake

以划分命名空间的方式将 64-bit位分割成多个部分
* 而 Java中64bit的整数是Long类型，所以在 Java 中 SnowFlake 算法生成的 ID 就是 long 来存储的
* 第1位占用1bit，其值始终是0，可看做是符号位不使用。
* 第2位开始的41位是时间戳，41-bit位可表示2^41个数，每个数代表毫秒，那么雪花算法可用的时间年限是(1L<<41)/(1000L360024*365)=69 年的时间
* 中间的10-bit位可表示机器数，即2^10 = 1024台机器，但是一般情况下我们不会部署这么台机器。如果我们对IDC（互联网数据中心）有需求，还可以将 10-bit 分 5-bit 给 IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，具体的划分可以根据自身需求定义。
* 最后12-bit位是自增序列，可表示2^12 = 4096个数。

这样的划分之后相当于在一毫秒一个数据中心的一台机器上可产生4096个有序的不重复的ID

<img width="319" alt="Screen Shot 2021-12-19 at 12 24 36 PM" src="https://user-images.githubusercontent.com/27160394/146663801-00f442b0-7a95-48a8-892a-0b4704abf0d5.png">


* 雪花算法生成的ID是趋势递增，不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的，而且可以根据自身业务特性分配bit位，非常灵活
* 雪花算法强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。如果恰巧回退前生成过一些ID，而时间回退后，生成的ID就有可能重复

----
# 百度 - UidGenerator

UidGenerator 提供了两种生成唯一ID方式
* DefaultUidGenerator
* CachedUidGenerator 官方建议如果有性能考虑的话使用 CachedUidGenerator 方式实现


<img width="350" alt="Screen Shot 2021-12-19 at 12 28 03 PM" src="https://user-images.githubusercontent.com/27160394/146663864-33987445-9fb5-4506-a970-6e9c5dab95fd.png">

* 第1位仍然占用1bit，其值始终是0
* 第2位开始的28位是时间戳，28-bit位可表示2^28个数，这里不再是以毫秒而是以秒为单位，每个数代表秒则可用（1L<<28）/ (360024365) ≈ 8.51 年的时间。 
* 中间的 workId （数据中心+工作机器，可以其他组成方式）则由 22-bit位组成，可表示 2^22 = 4194304个工作ID。 
* 最后由13-bit位构成自增序列，可表示2^13 = 8192个数。

## CachedUidGenerator 实现

* 使用`RingBuffer`缓存生成的id。数组每个元素成为一个slot。
  * RingBuffer容量，默认为Snowflake算法中sequence最大值（2^13 = 8192）。
  * 可通过 boostPower 配置进行扩容，以提高 RingBuffer 读写吞吐量
* Tail指针、Cursor指针用于环形数组上读写slot
  *  Tail指针 表示Producer生产的最大序号(此序号从0开始，持续递增)。Tail不能超过Cursor，即生产者不能覆盖未消费的slot。当Tail已赶上curosr，此时可通过rejectedPutBufferHandler指定PutRejectPolicy
  *  Cursor指针 表示Consumer消费到的最小序号(序号序列与Producer序列相同)。Cursor不能超过Tail，即不能消费未生产的slot。当Cursor已赶上tail，此时可通过rejectedTakeBufferHandler指定TakeRejectPolicy
----
# 美团Leaf

Leaf 也提供了两种ID生成的方式
* Leaf-segment 数据库方案
* Leaf-snowflake 方案

Leaf-segment 数据库方案
* 原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。
* 各个业务不同的发号需求用`biz_tag`字段来区分，每个`biz-tag`的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，只需要对biz_tag分库分表就行
